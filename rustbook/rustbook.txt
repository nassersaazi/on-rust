The Rust Programming Language Book

Chapter 1(Getting Started)
- using a ! means that you’re calling a macro instead of a normal function
-  Often, cargo check is much faster than cargo build, because it skips the step of producing an executable.  If you’re continually checking your work while writing the code, using cargo check will speed up the process

Chapter 2(Programming a Guessing Game)

- In Rust, variables are immutable by default
- Like variables, references are immutable by default
- The :: syntax in the ::new line indicates that new is an associated function of the String type. An associated function is implemented on a type, in this case String, rather than on a particular instance of a String. Some languages call this a static method 
- The Result types are enumerations, often referred to as enums. An enumeration is a type that can have a fixed set of values, and those values are called the enum’s variants 
- For Result, the variants are Ok or Err. The Ok variant indicates the operation was successful, and inside Ok is the successfully generated value. The Err variant means the operation failed, and Err contains information about how or why the operation failed.  The purpose of these Result types is to encode error-handling information. Values of the Result type, like values of any type, have methods defined on them. An instance of io::Result has an expect method that you can call.  If this instance of io::Result is an Err value, expect will cause the program to crash and display the message that you passed as an argument to expect
- A crate is a collection of Rust source code files
- A match expression is made up of arms. An arm consists of a pattern and the code that should be run if the value given to the beginning of the match expression fits that arm’s pattern. Rust takes the value given to match and looks through each arm’s pattern in turn. The match construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all
- Rust allows us to shadow the previous value of guess with a new one. This feature is often used in situations in which you want to convert a value from one type to another type
- The loop keyword creates an infinite loop

Chapter 3(Common Programming Concepts)

- Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.
- The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name.
- A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters
- (Note that char literals are specified with single quotes, as opposed to string literals, which use double quotes
- Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays
- In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (.) followed by the index of the value we want to access
- Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples
- An array is a single chunk of memory allocated on the stack. Arrays are useful when you want your data allocated on the stack rather than the heap (more on stacks and heaps in Chapter 4) or when you want to ensure you always have a fixed number of elements.
-An array isn’t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size. An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It’s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items
- If you want to create an array that contains the same value for each element, you can specify the initial value, followed by a semi- colon, and then the length of the array in square brackets, as shown here:
    let a = [3;5]; -> The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.
- Rust code uses snake case as the conventional style for function and variable names. In snake case, all letters are lowercase and underscores separate words
- Function parameters don’t all need to be the same type
- Statements are instructions that perform some action and do not return a value. Expressions evaluate to a resulting value. Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, {}, is an expression
- Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.
- The most common constructs that let you control the flow of execution of Rust code are if expressions and loops
- Blocks of code associated with the conditions in if expressions are sometimes called arms, just like the arms in match expressions
-  Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide if with a Boolean as its condition
- Given multiple else if expressions, Rust only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest
- Using too many else if expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called match for these cases
- Because if is an expression, we can use it on the right side of a let statement. Blocks of code evaluate to the last expression in them, and numbers by themselves are also expressions. In this case, the value of the whole if expression depends on which block of code executes. This means the values that have the potential to be results from each arm of the if must be the same type. If the types are mismatched, we’ll get an error
- Rust provides a way to break out of a loop. You can place the break keyword within the loop to tell the program when to stop executing the loop
- One of the uses of a loop is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the break expression you use to stop the loop; that value will be returned out of the loop so you can use it
- The while construct eliminates a lot of nesting that would be necessary if you used loop, if, else, and break, and it’s clearer. While a condition holds true, the code runs; otherwise, it exits the loop

Chapter 4(Understanding Ownership)

- All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead
- Pushing to the stack is faster than allocating on the heap because the operating system never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work, because the operating system must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.
- Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Knowing that managing heap data is why ownership exists can help explain why it works the way it does

Ownership rules
- Each value in Rust has a variable that’s called its owner
- There can be only one owner at a time
- When the owner goes out of scope, the value will be dropped

Chapter 9(Error Handling)
- Rust groups errors into two major categories: recoverable and unrecoverable errors. For a recoverable error, such as a file not found error, we most likely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, like trying to access a location beyond the end of an array, and so we want to immediately stop the program
- Rust doesn’t have exceptions. Instead, it has the type Result<T, E> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error.
- The ? operator can only be used in functions whose return type is compatible with the value the ? is used on. This is because the ? operator is defined to perform an early return of a value out of the function
- ? can be used with Option<T> values as well. As with using ? on Result, you can only use ? on Option in a function that returns an Option. The behavior of the ? operator when called on an Option<T> is similar to its behavior when called on a Result<T, E>: if the value is None, the None will be returned early from the function at that point. If the value is Some, the value inside the Some is the resulting value of the expression and the function continues
- Returning Result is a good default choice when you’re defining a function that might fail. In situations such as exampleall. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a Result indicates that failure is an expected possibility that the calling code must decide how to handle

Chapter 10(Generic Types, Traits and Lifetimes)
- We use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types
- The process of monomorphization makes Rust’s generics extremely efficient at runtime
- A trait defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.
- Traits are similar to a feature often called interfaces in other languages, although with some differences
- Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose
- Every reference in Rust has a lifetime, which is the scope for which that reference is valid
- The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference
- The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid
- Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter
- When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. The lifetime annotations become part of the contract of the function, much like the types in the signature
- When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters
- Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety
- It’s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.
- Lifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes

Chapter 11(Writing Automated Tests)
- Test functions typically perform 3 actions
    - Set up any needed data or state.
    - Run the code you want to test.
    - Assert the results are what you expect.
- Under the surface, the assert_eq! and assert_ne! macros use the operators == and !=, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the PartialEq and Debug traits. All primitive types and most of the standard library types implement these traits. For structs and enums that you define yourself, you’ll need to implement PartialEq to assert equality of those types. You’ll also need to implement Debug to print the values when the assertion fails. Because both traits are derivable traits, this is usually as straightforward as adding the #[derive(PartialEq, Debug)] annotation to your struct or enum definition
- Writing tests so they return a Result<T, E> enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an Err variant
- The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test)
- To run all the tests in a particular integration test file, use the --test argument of cargo test followed by the name of the file
- If a project is a binary crate that only contains a src/main.rs file and doesn’t have a src/lib.rs file, we can’t create integration tests in the tests directory and bring functions defined in the src/main.rs file into scope with a use statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.
- This is one of the reasons Rust projects that provide a binary have a straightforward src/main.rs file that calls logic that lives in the src/lib.rs file. Using that structure, integration tests can test the library crate with use to make the important functionality available. If the important functionality works, the small amount of code in the src/main.rs file will work as well, and that small amount of code doesn’t need to be tested.


Chapter 12(Building a command-line program)
- Iterators produce a series of values, and we can call the collect method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces 
- The Rust community has developed guidelines for splitting the separate concerns of a binary program when main starts getting large. This process has the following steps:

    Split your program into a main.rs and a lib.rs and move your program’s logic to lib.rs.
    As long as your command line parsing logic is small, it can remain in main.rs.
    When the command line parsing logic starts getting complicated, extract it from main.rs and move it to lib.rs.

- The responsibilities that remain in the main function after this process should be limited to the following:

    Calling the command line parsing logic with the argument values
    Setting up any other configuration
    Calling a run function in lib.rs
    Handling the error if run returns an error

- This pattern is about separating concerns: main.rs handles running the program, and lib.rs handles all the logic of the task at hand. Because you can’t test the main function directly, this structure lets you test all of your program’s logic by moving it into functions in lib.rs. The code that remains in main.rs will be small enough to verify its correctness by reading it

todos:
- read -> https://timothya.com/learning/implementing-tcp-in-rust-attempt-1-rust/
- read https://dev.to/opendataanalytics/learning-rust-by-building-a-to-do-app-2okd
- write article on 'ownership' in Rust -> after reading chapter 4 of the Rustbook
- write article on 'enums' in Rust -> after reading chapter 6 of the Rustbook
- write article <Half an hour to Learn Bitcoin from the Commandline> -> inspiration - (https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line ,https://fasterthanli.me/articles/a-half-hour-to-learn-rust )
- create 'learnrust.xyz' -> similar to 'bitcoincore.reviews', but for discussing rust books and rust open-source projects(current reading list -> rustbook, command-line rust, rust for rustaceans)

